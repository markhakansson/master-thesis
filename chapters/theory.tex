\section{Rust programming language}

\section{RTIC}
RTIC (previously RTFM\cite{rtfm}) is a concurrency framework for embedded
systems based on the Stack Resource Policy\cite{srp} for scheduling tasks. It
abstracts many details of the underlying model from its users without any
significant overhead and a guaranteed deadlock-free execution. In RTIC the
user defines the application by defining the shared resources, the
initialization function and the \emph{tasks} in the system. The initialization
function is the first function to run in the application. It has complete
access to the hardware and is used to initialize the application and the
hardware itself, as well as initializing any shared resources that can only be
set during run-time. A \emph{task} is the unit of concurrency used within 
RTIC\. It can be bound to an interrupt vector, a \emph{hardware task}. Or not,
then it is a \emph{software task}. All tasks can be prioritized.

\section{Schedulability Analysis}
Response Time Analysis from \textit{Hard Real-Time Computing Systems}\cite{hardrealtimecomputingsystems}
\begin{equation}
    \begin{cases}
        R_{i}^{(0)} &= C_i + B_i \\
        R_{i}^{(s)} &= C_i + B_i + \sum\limits_{h: P_h > P_i} \left\lceil \frac{R_{i}^{s-1}}{T_h} \right\rceil
    \end{cases}
\end{equation}
\subsection{Stack Resource Policy}


\section{KLEE}
KLEE\cite{kleepaper} is a tool to generate test vectors for programs with the
ability to replay them, using symbolic execution. Compared to fuzz testing
where program input usually consists of randomized concrete values, symbolic
execution handles input as symbolic values which are arbitrary. These values
are handled by an interpreter which executes the program and keeps track of the
states where the symbolic values are used for branching paths (e.g.\
conditional branches such as `if' and `else') and modifications to and/or using
those values. Then for each state it utilizes an SMT solver to find for which
values the symbolic values should be in order to enter those branches or invalid
modifications. This could be the case where an array is accessed using a
symbolic value as the index. The SMT solver will find that the array will be
accessed out of bonds for certain values of it. Thus producing two branches,
one where the array is not accessed out of bonds and one where it is. As the
symbolic value changes over the program, the intepreter creates a tree for all
possible branching paths of its value. Finally when the program terminates KLEE
will output the test vectors and the user can replay those test vectors on the
program.

